package design.proxy;

/**
 * 
 * 代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。
 * 代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。
 * 
 * 为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。
 * 通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，
 * 同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。
 * 
 * @author Three 2/28/2015
 * 
 */
public class NoteProxy {

	/*
	 * 静态代理
	 * 
	 * Subject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。
	 * 
	 * RealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。
	 * 
	 * Proxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现 ，
	 * 并且在具体主题角色处理完毕前后做预处理和善后工作。(最简单的比如打印日志)
	 * 
	 * @see StaticProxyMain
	 */
	
	/*
	 * 动态代理 
	 * 
	 * 动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。
	 * 
	 * java.lang.reflect.Proxy：这是 Java 动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。
	 * java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。
	 * java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到 Java 虚拟机(JVM)中并为其定义类对象，然后该类才能被使用。
	 * 
	 * 具体有如下四步骤： 
	 * 	通过实现 InvocationHandler 接口创建自己的调用处理器；
	 *  通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；
	 *  通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；
	 *  通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。
	 * 
	 * Java 动态代理机制的一些特点:
	 * (1)包：如果所代理的接口都是 public的，那么它将被定义在顶层包(即包路径为空)，
	 * 	如果所代理的接口中有非 public的接口(因为接口不能被定义为 protect或 private，所以除 public之外就是默认的 package访问级别)，
	 * 	那么它将被定义在该接口所在包(假设代理了 com.ibm.developerworks包中的某非 public接口 A，
	 * 	那么新生成的代理类所在的包就是 com.ibm.developerworks)，
	 * 	这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；
	 * (2)类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；
	 * (3)类名：格式是“$ProxyN”，其中 N是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N次生成的动态代理类，
	 * 	值得注意的一点是，并不是每次调用 Proxy的静态方法创建动态代理类都会使得 N值增加，
	 * 	原因是如果对同一组接口(包括接口排列的顺序相同)试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，
	 * 	而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。
	 * 
	 * @see DynamicProxyMain
	 * 
	 * @see http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/
	 * @see http://www.ibm.com/developerworks/cn/java/j-dynproxies.html
	 * @see http://www.ibm.com/developerworks/cn/java/j-jtp08305.html
	 * 
	 */

	/*
	 * 代理模式的应用形式
	 * 
	 * (1)远程代理(Remote Proxy)-可以隐藏一个对象存在于不同地址空间的事实。
	 * 	也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。  
	 * (2)虚拟代理(Virtual Proxy)C允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。 
	 * (3)写入时复制代理(Copy-On-Write Proxy)C用来控制对象的复制，方法是延迟对象的复制， 直到客户真的需要为止。是虚拟代理的一个变体。 
	 * (4)保护代理(Protection (Access)Proxy)C为不同的客户提供不同级别的目标对象访问权限 
	 * (5)缓存代理(Cache Proxy) C 为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。
	 * (6)防火墙代理(Firewall Proxy) C 控制网络资源的访问，保护主题免于恶意客户的侵害。
	 * (7)同步代理(SynchronizationProxy) C 在多线程的情况下为主题提供安全的访问。 
	 * (8)智能引用代理(Smart ReferenceProxy)- 当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 
	 * (9)复杂隐藏代理(Complexity HidingProxy) C 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。
	 * 	有时候也称为外观代理(Facade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，
	 * 	而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。
	 * 
	 */
}
